from collections import OrderedDict
import datetime
import pytz

from lib.util_sqlalchemy import AwareDateTime
from snakeeyes.extensions import db, login_manager
from collections import OrderedDict
from werkzeug.security import generate_password_hash, check_password_hash

from itsdangerous import URLSafeTimedSerializer, TimedJSONWebSignatureSerializer

from lib.util_sqlalchemy import AwareDateTime, ResourceMixin
from snakeeyes.blueprints.billing.models.credit_card import CreditCard
from snakeeyes.blueprints.billing.models.subscription import Subscription
# from snakeeyes.blueprints.billing.models.invoice import Invoice
from flask_login import UserMixin
from sqlalchemy import or_
from flask import current_app, request





@login_manager.user_loader
def load_user(user_id):
    return User.query.get(user_id)


class User(db.Model, ResourceMixin, UserMixin):

    ROLE = OrderedDict([
        ('member', "Member"),
        ("admin", "Admin")
    ])

    __tablename__ = 'users'


    # user unique ID generated by flask-sqlalchemy 
    id = db.Column(db.Integer(), primary_key= True, nullable = False)

    # Credit card relationship
    credit_card = db.relationship(CreditCard, uselist=False, backref='users',
    
                                  passive_deletes=True)
    # Subscription relationship
    subscription = db.relationship(Subscription, uselist=False,
                                   backref='users', passive_deletes=True)
    # invoices = db.relationship(Invoice, backref='users', passive_deletes=True)

    # user credentials
    role = db.Column(db.Enum(*ROLE, name = 'role_types', native_enum = False), index= True, nullable = False , server_default = 'member')
    username =db.Column(db.String(30), nullable = True, unique = True)
    email = db.Column(db.String(128), nullable = False, unique = True, server_default='')
    password = db.Column(db.String(128), nullable = False, unique = False, server_default='')
    active = db.Column(db.Boolean, server_default = '1', nullable = False  )

    # user traccking 
    sign_in_count = db.Column(db.Integer, nullable=False, default=0)
    current_sign_in_on = db.Column(AwareDateTime())
    current_sign_in_ip = db.Column(db.String(45))
    last_sign_in_on = db.Column(AwareDateTime())
    last_sign_in_ip = db.Column(db.String(45))


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.password = User.encrypt_password(kwargs.get('password', ''))


    @classmethod
    def encrypt_password(cls, plaintext_password):
        if plaintext_password:
            return generate_password_hash(plaintext_password)
        return None

    
    @classmethod
    def find_by_identity(cls, identity):
        # the flask logger gives us information about an error about a user who tries to login with wrong details with IP address
        # Always add this current_app.loger... after seeding database
        current_app.logger.debug('{0} has tried to login with ip : {1}'.format(identity, (request.remote_addr)))
        find = User.query.filter( (User.username == identity) | (User.email == identity) ).first()
        return find

    
    def serialize_token(self, expiration=3600 ):
        private_key = current_app.config['SECRET_KEY']
        serializer = TimedJSONWebSignatureSerializer(private_key, expires_in=expiration)
        return serializer.dumps({'user_mail' : self.email}).decode('utf-8')


    @classmethod
    def deserializer_token(cls, token):
        private_key = TimedJSONWebSignatureSerializer(current_app.config['SECRET_KEY'])
        try:
            decode_payload = private_key.loads(token)
            return User.find_by_identity(decode_payload.get('user.email'))
        except Exception:
            return None


    
    @classmethod
    def initialize_password_reset(cls, identity):
        """
        Generate a token to reset the password for a specific user.

        :param identity: User e-mail address or username
        :type identity: str
        :return: User instance
        """
        u = User.find_by_identity(identity)
        reset_token = u.serialize_token()

        # This prevents circular imports.
        from snakeeyes.blueprints.user.tasks import (
            deliver_password_reset_email)
        deliver_password_reset_email.delay(u.id, reset_token)

        return u


    @classmethod
    def search(cls, query):
        """
        Search a resource by 1 or more fields.

        :param query: Search query
        :type query: str
        :return: SQLAlchemy filter
        """
        if not query:
            return ''

        search_query = '%{0}%'.format(query)
        search_chain = (User.email.ilike(search_query),
                        User.username.ilike(search_query))

        return or_(*search_chain)


    @classmethod
    def is_last_admin(cls, user, new_role, new_active):
        """
        Determine whether or not this user is the last admin account.

        :param user: User being tested
        :type user: User
        :param new_role: New role being set
        :type new_role: str
        :param new_active: New active status being set
        :type new_active: bool
        :return: bool
        """

        is_changing_roles = user.role == 'admin' and new_role != 'admin'
        is_changing_active = user.active is True and new_active is None

        if is_changing_roles or is_changing_active:
            admin_count = User.query.filter(User.role == 'admin').count()
            active_count = User.query.filter(User.is_active is True).count()

            if admin_count == 1 or active_count == 1:
                return True

        return False



    def is_active(self):
        """HElp to check wether the account is active or not """
        return self.active 
    
    
    def authenticated(self, with_password=True, password = ''):
        if with_password:
            return check_password_hash(self.password, password)

    def tracking_activities(self, ip_address):
        """This help to track activities of the user"""
        self.sign_in_count += 1 

        self.last_sign_in_on = self.current_sign_in_on
        self.last_sign_in_ip = self.current_sign_in_ip

        self.current_sign_in_on = datetime.datetime.now(pytz.utc)
        self.current_sign_in_ip = ip_address

        return self.save()    



























































































    # # user tracking 
    # sign_in_count = db.Column(db.Integer(), nullable = False, default = 0 )
    # current_sign_in_on = db.Column(db.DateTime(), default = datetime.utcnow, nullable = False)
    # current_sign_in_ip = db.Column(db.String(128), nullable = False)
    # last_sign_in_on = db.Column(db.DateTime(), default = datetime.utcnow ,  nullable = False )
    # last_sign_in_ip = db.Column(db.String(128), nullable = False)

    # def save(self):
    #     db.session.add(self)
    #     db.session.commit()

    #     return self

    # def delete(self):
    #     db.session.delete(self)
    #     return db.session.commit()

    # def __repr__(self):
    #     return f' User {self.username} {self.email} {self.active}'