from collections import OrderedDict
from datetime import datetime

from lib.util_sqlalchemy import AwareDateTime
from snakeeyes.extensions import db 
from collections import OrderedDict
from werkzeug.security import generate_password_hash, check_password_hash

from itsdangerous import URLSafeTimedSerializer, TimedJSONWebSignatureSerializer

from lib.util_sqlalchemy import AwareDateTime, ResourceMixin

from flask_login import UserMixin

from flask import current_app
from snakeeyes.extensions import login_manager




@login_manager.user_loader
def load_user(user_id):
    return User.query.get(user_id)


class User(db.Model, ResourceMixin, UserMixin):

    ROLE = OrderedDict([
        ('member', "Member"),
        ("admin", "Admin")
    ])

    __tablename__ = 'users'


    # user unique ID generated by flask-sqlalchemy 
    id = db.Column(db.Integer(), primary_key= True, nullable = False)

    # user credentials
    role = db.Column(db.Enum(*ROLE, name = 'role_types', native_enum = False), index= True, nullable = False , server_default = 'member')
    username =db.Column(db.String(30), nullable = True, unique = True)
    email = db.Column(db.String(128), nullable = False, unique = True)
    password = db.Column(db.String(128), nullable = False, unique = False)
    active = db.Column(db.Boolean, server_default = '1', nullable = False  )

    # user traccking 
    sign_in_count = db.Column(db.Integer, nullable=False, default=0)
    current_sign_in_on = db.Column(AwareDateTime())
    current_sign_in_ip = db.Column(db.String(45))
    last_sign_in_on = db.Column(AwareDateTime())
    last_sign_in_ip = db.Column(db.String(45))


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.password = User.encrypt_password(kwargs.get('password', ''))


    @classmethod
    def encrypt_password(cls, plaintext_password):
        if plaintext_password:
            return generate_password_hash(plaintext_password)
        return None

    
    @classmethod
    def find_by_identity(cls, identity):
        find = User.query.filter( (User.username == identity) | (User.email == identity) ).first()
        return find

    
    def serialize_token(self, expiration=3600 ):
        private_key = current_app.config['SECRET_KEY']
        serializer = TimedJSONWebSignatureSerializer(private_key, expires_in=expiration)
        return serializer.dumps({'user_mail' : self.email}).decode('utf-8')


    @classmethod
    def deserializer_token(cls, token):
        private_key = TimedJSONWebSignatureSerializer(current_app.config['SECRET_KEY'])
        try:
            decode_payload = private_key.loads(token)
            return User.find_by_identity(decode_payload.get('user.email'))
        except Exception:
            return None


    def is_active(self):
        """HElp to check wether the account is active or not """
        return self.active 
    
    
    def authenticated(self, with_password=True, password = ''):
        if with_password:
            return check_password_hash(self.password, password)

    def tracking_activities(self, ip_address):
        """This help to track activities of the user"""
        self.last_sign_in_on = self.current_sign_in_on
        self.last_sign_in_ip = self.current_sign_in_ip

        self.current_sign_in_on = datetime.datetime.now(pytz.utc)
        self.current_sign_in_ip = ip_address

        return self.save()    



























































































    # # user tracking 
    # sign_in_count = db.Column(db.Integer(), nullable = False, default = 0 )
    # current_sign_in_on = db.Column(db.DateTime(), default = datetime.utcnow, nullable = False)
    # current_sign_in_ip = db.Column(db.String(128), nullable = False)
    # last_sign_in_on = db.Column(db.DateTime(), default = datetime.utcnow ,  nullable = False )
    # last_sign_in_ip = db.Column(db.String(128), nullable = False)

    # def save(self):
    #     db.session.add(self)
    #     db.session.commit()

    #     return self

    # def delete(self):
    #     db.session.delete(self)
    #     return db.session.commit()

    # def __repr__(self):
    #     return f' User {self.username} {self.email} {self.active}'